# Trabalho 2 – Inteligência Artificial II (2025/02)

## Visão Geral

- Problema/Dor: pequenos varejistas enfrentam dificuldade em prever demanda e repor estoque corretamente, gerando ruptura ou sobre-estoque.
- Solução Proposta: módulo de IA que prevê demanda diária por produto e recomenda reposição e promoções, integrado ao sistema NexSale (backend Rust + frontend React/Vite).
- Modalidade escolhida: Treinamento de rede neural (MLP) para previsão de séries temporais e integração funcional ao produto. A integração é usada para demonstração do valor gerado, mas o eixo técnico principal é o treino de rede.

## Objetivos

- Prever demanda de curto prazo por produto (horizonte de 7 dias).
- Calcular reposição sugerida com base em `lead_time` e `service_level`.
- Sugerir promoções para itens com sobre-estoque.
- Integrar previsões e recomendações ao dashboard do NexSale, com visualização e operação simples.

## Arquitetura

- Backend (Rust): expõe endpoint `GET /api/ai/recommendations` que aciona scripts Python e retorna JSON de previsões e recomendações.
- Módulo IA (Python):
  - `train_mlp.py`: treina MLP (TensorFlow/Keras) e salva artefatos.
  - `infer_recommendations.py`: realiza inferência, gera previsões e recomendações com base nos artefatos.
  - `utils.py`: leitura de ambiente e helpers.
- Frontend (React/Vite): exibe seção de IA com gráficos e listas de recomendações.

Componentes e Artefatos
- Modelo: `nexsale-backend/ai/models/best_model.keras` (Keras SavedModel).
- Metadados/Scaler: `nexsale-backend/ai/models/best_model.pkl` (via `joblib`).
- Métricas: `nexsale-backend/ai/reports/metrics.json`.

## Abordagem Técnica

- Tipo de modelo: MLP (Multi-Layer Perceptron) com camadas Dense e Dropout.
- Loss: Huber; Otimizador: Adam; EarlyStopping + ReduceLROnPlateau.
- Features: médias móveis (`ma_7`, `ma_14`), lag (`lag_1`), tendência (`trend_7_30`), sazonalidade mensal (`month_sin`, `month_cos`), dia da semana (`dow_0..dow_6`, `is_weekend`), índice categórico de produto (`pid_idx`).
- Split temporal: últimos 28 dias para teste; fração de validação sobre treino.
- Baseline: média móvel (7 dias) para comparação objetiva.

Exemplo de Métricas (do repositório)
- `RMSE`: ~0.3295
- `MAE`: ~0.3003
- `SMAPE`: ~0.1064
- Baseline `RMSE`: ~1.7001; `MAPE`: ~0.4703

## Requisitos e Ambiente

- Python 3.11 recomendado.
- Instalação rápida (Windows/Linux/macOS):
  - `python -m pip install -r nexsale-backend/ai/requirements.txt`
  - Em Windows, TF CPU: `tensorflow-cpu==2.16.1` já está no `requirements`.
- Variáveis de ambiente:
  - `DATABASE_URL` ou `CONTROL_DATABASE_URL` apontando para seu Postgres.

## Dataset

- Origem: base transacional NexSale (tabelas `sales`, `sale_items`, `products`).
- Agregação: diária por produto (`SUM(quantity)`), com `product_name` e datas normalizadas.
- Opcional para testes: geração sintética com `seed_data.py`.

## Passo a Passo de Execução

1) Preparar ambiente
   - Configurar Postgres e popular dados de vendas e produtos, ou usar semente sintética.
   - Exportar `DATABASE_URL` ou `CONTROL_DATABASE_URL`.

2) Instalar dependências de IA
   - `python -m pip install -r nexsale-backend/ai/requirements.txt`

3) Semeadura sintética (opcional)
   - `python -m nexsale-backend.ai.seed_data --client-id <UUID> --days 120 --products-limit 3`

4) Treinar o modelo
   - `python -m nexsale-backend.ai.train_mlp --client-id <UUID>`
   - Artefatos gerados:
     - `nexsale-backend/ai/models/best_model.keras`
     - `nexsale-backend/ai/models/best_model.pkl`
     - `nexsale-backend/ai/reports/metrics.json`

5) Rodar inferência
   - `python -m nexsale-backend.ai.infer_recommendations --client-id <UUID> --horizon 7`
   - Saída: JSON com `forecasts`, `stock_recommendations`, `promo_recommendations`.

6) Integrar e visualizar no sistema
   - Backend Rust (em `nexsale-backend/`): `cargo run --bin nexsale-backend`
   - Frontend (em `nexsale_front-end/`): `npm run dev` e abrir `http://localhost:5173/`
   - Navegar até o Dashboard e conferir a seção de IA (gráficos e recomendações).

## Exemplos de Resultados

- Métricas: ver `ai/reports/metrics.json`.
- Visualizações: gráficos no frontend comparando previsão x vendas (últimos dias), baseline e recomendações.
- Logs: saída do treino mostra métricas e caminhos dos artefatos; inferência imprime JSON.

## Validação e Critérios (Professor)

- Complexidade: rede neural com engenharia de features e avaliação robusta; integração end-to-end.
- Originalidade/Relevância: dor real do varejo; solução aplicável e com valor (redução de ruptura/sobre-estoque).
- Reprodutibilidade: scripts, env, passos e visualizações documentados.

## Apresentação (Pitch até 7 minutos)

- Problema/Dor: ruptura e sobre-estoque em pequenos varejos.
- Solução: previsão de demanda + recomendações de reposição/promoção (IA integrada ao NexSale).
- Demonstração: rodar inferência e mostrar dashboard com gráficos e recomendações.
- Impacto e próximos passos: ajustes de arquitetura (ex.: LSTM, Prophet), tuning de hiperparâmetros, virtualização de listas no frontend, automação de retrain, escalabilidade multi-cliente.

## Orientações de Entrega

- Grupo: até 3 integrantes (dupla/individual precisam de validação prévia).
- Data: até 02/12/2025 às 12h.
- Entrega: link do GitHub no Google Classroom; slides da apresentação dentro do repositório.
- Repositórios privados: compartilhar com `rwfazul`.
- Ética/anti-plágio: uso responsável de IA; entendimento crítico das respostas e das implementações.

## Observações Importantes

- Fallback sem TensorFlow: quando TF indisponível, o sistema utiliza baseline (média móvel) para métricas e inferência; o treino completo exige TF.
- Parametrização de negócio: `AI_LEAD_TIME_DAYS` e `AI_SERVICE_LEVEL` (ex.: 0.95) podem ser usados para ajustar estoque de segurança e reposição.

## Como este projeto atende às exigências

- Modalidade 1 (Treinamento de rede neural): implementada com MLP Keras, métricas e comparação com baseline.
- Integração funcional ao produto: backend expõe API e frontend visualiza; demonstração clara de valor.
- Entregáveis: README detalhado, código-fonte completo, instruções de reprodução, exemplos de resultados e visualizações.

## Próximas Melhorias Sugeridas

- Trocar arquitetura para LSTM/Temporal Convolution para capturar etapas temporais mais longas.
- Hiperparâmetros e regularização (grid ou Bayesian optimization).
- Fine-tuning por cliente com transferência de aprendizado.
- Monitoramento de drift e re-treino automático.
- Integração com RAG para notas de compra e insights.
